# Tool adapters

This reference gathers the CLI adapter details for running external tools through mcp-agent workflows.

## Google Antigravity CLI adapter

Use the Antigravity tool adapter when you want agents to drive the Google Antigravity CLI with full workspace awareness, live streams, and MCP connectivity.

- **Installation:** install the CLI locally (for example, `uvx antigravity --version`). The adapter surfaces a ``binary`` parameter if the executable lives outside `$PATH`.
- **Workspace & projects:** pass ``workspace``/``project`` on the constructor or per-call; ``.antigravity.json`` is auto-discovered from the workspace root and forwarded via ``--config``.
- **Commands:** ``command``, ``plan``, ``review``, ``refactor``, ``test``, ``doc``, ``agent``, and ``mcp`` all map directly to the CLI flags (``--agent``, ``--params``, ``--stream``, ``--json``, ``--scope``, ``--format``, ``--args``, ``--config``, etc.).
- **Streaming:** when ``stream=True``, results arrive as async events so workflows can emit partial updates while the CLI runs.
- **MCP integration:** ``mcp_register``, ``mcp_unregister``, ``mcp_list``, and ``mcp_invoke`` wrap Antigravity's MCP management commands to register remote tools alongside local operations.

Example:

```python
from mcp_agent.tools.antigravity_tool import AntigravityTool

tool = AntigravityTool(workspace="/repo/project", project="demo")

async for event in (await tool.review(stream=True)).stream:
    print("[review]", event.text)

result = await tool.mcp_invoke("supabase.schema", params={"db": "main"})
print("Schema response", result.stdout)
```

Docs: The adapter is fully typed and documented in `src/mcp_agent/tools/antigravity_tool.py`, including error handling, timeouts, and streaming semantics.

Docs: [CLI reference](https://docs.mcp-agent.com/reference/cli) • [Getting started guides](https://docs.mcp-agent.com/get-started/quickstart).

## Grok CLI adapter

`GrokTool` provides full programmatic access to the Grok CLI, mirroring all documented flags and MCP extensions.

- **Installation:** install the Grok CLI (for example, `uvx grok --version`); set the API key via `GROK_API_KEY`, `.env`, or constructor.
- **Workspace & context:** pass `directory`/`workspace`, `model`, `base_url`, `max_tool_rounds`, and `prompt` to match `grok` top-level flags. Short or long switches are supported through `prefer_short_flags`.
- **Usage modes:** call `run()` without a prompt for interactive flows or with `prompt` for headless/CI runs. `version()` and `help()` expose `--version`/`--help`.
- **Streaming:** set `stream=True` on `run()` or `run_raw()` to receive `GrokStreamEvent` updates in real time; JSON streams are parsed when `parse_json_stream=True`.
- **MCP integration:** `mcp_add`, `mcp_add_json`, `mcp_list`, `mcp_test`, and `mcp_remove` map directly to Grok's MCP commands, including transport, command, URL, argument, environment, and inline JSON configuration wiring.
- **Morph Fast Apply:** enable `morph_fast_apply=True` or supply `MORPH_API_KEY` to surface Morph-specific acceleration flags to the CLI environment.

Example:

```python
from mcp_agent.tools.grok_tool import GrokTool

grok = GrokTool(workspace="/repo", api_key="sk-...", model="grok-code-fast-1")

async for event in (await grok.run(prompt="List TODOs", max_tool_rounds=25, stream=True)).stream:
    print(event.text)

await grok.mcp_add(
    "db",
    transport="http",
    url="http://localhost:4040",
    command="db-mcp",
    env={"API_KEY": "your_key"},
)
await grok.mcp_add_json("linear", '{"command":"bun","args":["server.js"],"env":{"API_KEY":"token"}}')
print(await grok.mcp_list())
```

## Kimi CLI adapter

`KimiTool` exposes the MoonshotAI Kimi CLI for agent workflows, including interactive sessions, prompt-based asks, chat, configuration, history, and MCP connectivity.

- **Authentication:** keys are resolved from the ``api_key`` argument, ``KIMI_API_KEY`` environment variable, project ``.kimi/settings.json``, global ``~/.kimi/user-settings.json``, or project ``.env``. Missing keys raise a descriptive error and you can seed credentials with ``kimi config set-key``.
- **Models & context:** set ``model`` per-call or via ``MOONSHOT_MODEL``; working directories are forwarded through the adapter so per-project context is preserved.
- **Commands:** ``run`` launches an interactive shell, ``ask`` issues one-shot prompts, ``chat`` opens a dialogue session, ``config_show``/``config_set_key`` manage CLI config, and ``history_list`` mirrors ``kimi history list``.
- **MCP integration:** pass ``mcp_config_file`` to forward a validated MCP JSON file with ``--mcp-config-file`` for tool connectivity.
- **Streaming:** set ``stream=True`` on supported methods or ``run_raw`` to receive ``KimiStreamEvent`` updates in real time.

Example:

```python
from mcp_agent.tools.kimi_tool import KimiTool

kimi = KimiTool(workspace="/repo", api_key="kimi-...")
response = await kimi.ask("Summarize this project")

await kimi.run(mcp_config_file="/repo/kimi_mcp.json", model="kimi-k2-turbo-preview")
print(await kimi.config_show())
```

## Qwen Code CLI adapter

`QwenTool` exposes every documented Qwen Code CLI flag, slash command, and MCP hook so agents can drive the CLI headlessly or stream updates into workflows.

- **Authentication:** API keys resolve from the ``api_key`` argument, ``QWEN_API_KEY`` environment variable, or a project ``.env``. Missing keys raise a descriptive error so callers can prompt the user upstream if desired.
- **Prompting & workspace context:** ``prompt`` mirrors ``qwen --prompt`` and forwards ``--include-directories``, ``--checkpointing``, ``--model``, ``--base-url``, and ``--mcp-config-file``. ``prompt_with_files`` expands ``@<path>`` blocks by reading project files while skipping binary content.
- **Slash commands:** helpers map 1:1 to Qwen’s controls: ``bug``, ``summary``, ``compress_history``, ``copy_output``, ``directory_add/show``, ``chat`` (save/resume/list/delete/share), ``mcp`` (list/schema/descriptions/nodescriptions), ``memory`` (add/show/refresh), ``restore``, ``stats``, ``approval_mode`` (plan/default/auto-edit/yolo with optional scope), ``agents`` (create/manage), and ``help``.
- **Shell passthrough:** ``run_shell`` prefixes commands with ``!`` and preserves workspace-aware execution. Use ``format_shell_command`` to build shell-safe invocations.
- **Custom commands:** ``run_custom`` loads TOML definitions from ``~/.qwen/commands`` or ``<workspace>/.qwen/commands`` (``prompt`` key with ``{{args}}`` substitution) and executes them via ``--prompt``.
- **MCP tooling:** forward CLI MCP config with ``--mcp-config-file`` or call ``mcp_list``, ``mcp_schema``, ``mcp_descriptions``, and ``mcp_nodescriptions`` to surface server health and tool schemas.

Example:

```python
from mcp_agent.tools.qwen_tool import QwenTool

qwen = QwenTool(workspace="/repo", api_key="qwen-...", include_directories=["src", "tests"], checkpointing=True)

async for event in (await qwen.prompt("@src/main.py Summarize the entrypoint", stream=True)).stream:
    print(event.text)

await qwen.directory_add("/repo/extra")
await qwen.approval_mode("plan", scope="project")
await qwen.run_custom("refactor:pure", args="handlers.py", workspace="/repo")
```
